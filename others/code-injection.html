<script>
  document.addEventListener("DOMContentLoaded", () => {
    // Function to process text nodes
    const processTextNodes = (node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        // Replace special tags in text content only
        const updatedText = node.textContent.replace(
          /(?:^|\s)([#@!])([\w\u0E00-\u0E7F-]+(?:[-\.]\w+)*)/g,
          (match, symbol, keyword) => {
            const trimmedMatch = match.trim(); // Remove leading space for correct replacement
            if (symbol === '#') {
              return `&nbsp<a target="_blank" href="/t/${keyword}" class="tag tag-hashtag">${trimmedMatch}</a>`;
            } else if (symbol === '@') {
              return `&nbsp<a target="_blank" href="/คน/${keyword}" class="tag tag-mention">${keyword}</a>`;
            } else if (symbol === '!') {
              return `&nbsp<a target="_blank" href="/สถานที่/${keyword}" class="tag tag-location">${keyword}</a>`;
            }
            return trimmedMatch;
          }
        );

        // If there's an update, replace the node with a new element
        if (updatedText !== node.textContent) {
          const wrapper = document.createElement('span');
          wrapper.innerHTML = updatedText;
          node.replaceWith(wrapper);
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        // Recursively process child nodes
        node.childNodes.forEach(processTextNodes);
      }
    };

    // Function to initialize processing
    const initializeObserver = () => {
      const contentContainer = document.querySelector('.contents');

      // Retry if content container is not found
      if (!contentContainer) {
        setTimeout(initializeObserver, 100); // Retry after 100ms
        return;
      }

      console.log('Content container found:', contentContainer);

      // Initial processing of the content
      processTextNodes(contentContainer);

      // Setup a MutationObserver to monitor changes in content
      const observer = new MutationObserver((mutationsList) => {
        for (const mutation of mutationsList) {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            mutation.target.childNodes.forEach(processTextNodes);
          }
        }
      });

      // Observe changes in the container
      observer.observe(contentContainer, {
        childList: true,
        subtree: true
      });
    };

    // Start the initialization process
    initializeObserver();
  });
</script>
